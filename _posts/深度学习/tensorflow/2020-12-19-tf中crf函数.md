---
layout:     post
title:      "tf-crf"
subtitle:   " \"tf\""
date:       2020-12-19 18:00:00
mathjax: true
author:     "zwt"
header-img: "img/post-bg-2015.jpg"
catalog: false
tags:
    - 工具
---
* TOC
{:toc}

# 预备知识
[CRF的损失函数](http://note.youdao.com/noteshare?id=01d14fa1838f9445ef56e2eb356a4e45&sub=46DAB246E40B451B85BB564E818F5FDC)为:
$$
LossFunction= \frac{P_{realpath}}{P_{1}+P_{2}+\ldots+P_{N}}
$$
其中$P_{realpath}$的计算定义为两部分的和：
- EmissionScore:这部分为BILSTM的输出
$$
\begin{array}{l}{\text { Emission Score: }} \\ {\text { EmissionScore }=x_{0, S T A R}+x_{1, B-\text {Person}}+x_{2, I-\text {Person}}+x_{3, O}+x_{4, B-\text {Orgnization}}+x_{5, O}+x_{6, E N D}}\end{array}
$$
- TransitionScore:这部分为CRF层的输出
$$
\begin{array}{l}{\text { Transition Score: }} \\ {\text { Transition. Score = }} \\ {t_{S T A R T->B-\text {Person}}+t_{B-\text {Person}->I-\text {Person}}+} \\ {t_{I-\text {Person}->O+t_{0->B-\text {Organization}}+t_{B-\text {Organization}-}}}t_{0}->END\end{array}
$$
则可以将损失函数简化为：
$$
Log Loss Function 
= - \log \frac{P_{RealPath}}{P_1 + P_2 + … + P_N} 

= - \log \frac{e^{S_{RealPath}}}{e^{S_1} + e^{S_2} + … + e^{S_N}} 
= - (\log(e^{S_{RealPath}}) - \log(e^{S_1} + e^{S_2} + … + e^{S_N}))

= - (S_{RealPath} - \log(e^{S_1} + e^{S_2} + … + e^{S_N}))

= - ( \sum_{i=1}^{N} x_{iy_i} + \sum_{i=1}^{N-1} t_{y_iy_{i+1}} - \log(e^{S_1} + e^{S_2} + … + e^{S_N}))
$$
其中$\sum_{i=1}^{N} x_{iy_i}, \sum_{i=1}^{N-1} t_{y_iy_{i+1}}$分别表示EmissionScore和TransitionScore

# 模块函数解析
- [参考1](https://blog.csdn.net/xiaoleiniu1314/article/details/94010649)，[参考2](https://blog.csdn.net/qq_41837900/article/details/100201109)
- 函数输入：
    - tag_indice:真实标签序列
    - sequence_lengths:[batch_size]，每个序列的长度
    - transition_params:[num_tags, num_tags],转移矩阵
    - inputs:[batch_size, max_seq_len, num_tags]，BILSTM的输出，同时也是CRF的输入
- crf_binary_score(二元概率):表示==TransitionScore（就是从第i个tag转移到第j个tag所得的分数，然后将句子中每个位置的状态转移所得的分数相加）==
    - 输入：tag_indice，sequence_lengths，transition_params
    - 输出：[batch_size]，向量中每个元素是一个sequence中所有转移概率之和
- crf_unary_score（一元概率）：==EmissionScore（就是在一个句子中，第i个单词对应第j个tag所得的分数，然后将句子中每个单词所得的分数相加）==
    - 输入：tag_indices, sequence_lengths, inputs
    - 输出：[batch_size],向量中每个元素是一个sequence中所有的真实标签概率加和
- crf_sequence_score:==EmissionScore+TransitionScore==
    - 输入：input, tag_indices, sequence_lengths, transition_params
    - 输出：[batch_size], 向量中的每个元素是一个sequence的真实概率+所有的转移概率之和
- crf_log_norm: 计算CRF的标准化.采用前向-后向算法
    - 输入：inputs, sequence_lengths, transition_params
    - 输出：[batch_size]，损失函数的后半部分
- crf_log_likelihood:计算 CRF 中标签序列的对数似然.
    - 输入：inputs, tag_indices, sequence_lengths
    - 输出：log_looklihood:[batch_size],向量中每个元素是损失函数的值，也就是-logloss。transition_params：[num_tags, num_tags]，状态转移矩阵
- crf_decode:维特比算法
    - 输入：potentials，transition_params，sequence_length
    - 输出：decode_tags:[batch_size, max_seq_len],所有可能的输出序列中概率最大的那个序列，best_score:[batch_size]，概率最大的序列对应的概率